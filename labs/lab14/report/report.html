<h1 id="цель">Цель</h1>
<p>Изучить основы программирования в оболочке ОС UNIX. Научиться писать
более сложные командные файлы с использованием логических управляющих
конструкций и циклов.</p>
<h1 id="задание">Задание</h1>
<ol type="1">
<li>Написать командный файл, реализующий упрощённый механизм семафоров.
Ко- мандный файл должен в течение некоторого времени t1 дожидаться
освобождения ресурса, выдавая об этом сообщение, а дождавшись его
освобождения, использовать его в течение некоторого времени
t2&lt;&gt;t1, также выдавая информацию о том, что ресурс используется
соответствующим командным файлом (процессом). Запустить командный файл в
одном виртуальном терминале в фоновом режиме, перенаправив его вывод в
другой (&gt; /dev/tty#, где # — номер терминала куда перенаправляется
вывод), в котором также запущен этот файл, но не фоновом, а в
привилегированном режиме. Доработать программу так, чтобы имелась
возможность взаимодействия трёх и более процессов.</li>
<li>Реализовать команду man с помощью командного файла. Изучите
содержимое ката- лога /usr/share/man/man1. В нем находятся архивы
текстовых файлов, содержащих справку по большинству установленных в
системе программ и команд. Каждый архив можно открыть командой less
сразу же просмотрев содержимое справки. Командный файл должен получать в
виде аргумента командной строки название команды и в виде результата
выдавать справку об этой команде или сообщение об отсутствии справки,
если соответствующего файла нет в каталоге man1.</li>
<li>Используя встроенную переменную $RANDOM, напишите командный файл,
генерирую- щий случайную последовательность букв латинского алфавита.
Учтите, что $RANDOM выдаёт псевдослучайные числа в диапазоне от 0 до
32767.</li>
</ol>
<h1 id="теоретическое-введение">Теоретическое введение</h1>
<p>Командный процессор (командная оболочка, интерпретатор команд shell)
— это про- грамма, позволяющая пользователю взаимодействовать с
операционной системой компьютера. В операционных системах типа
UNIX/Linux наиболее часто используются следующие реализации командных
оболочек: – оболочка Борна (Bourne shell или sh) — стандартная командная
оболочка UNIX/Linux, содержащая базовый, но при этом полный набор
функций; – С-оболочка (или csh) — надстройка на оболочкой Борна,
использующая С-подобный синтаксис команд с возможностью сохранения
истории выполнения команд; – оболочка Корна (или ksh) — напоминает
оболочку С, но операторы управления програм- мой совместимы с
операторами оболочки Борна; – BASH — сокращение от Bourne Again Shell
(опять оболочка Борна), в основе своей сов- мещает свойства оболочек С и
Корна (разработка компании Free Software Foundation). POSIX (Portable
Operating System Interface for Computer Environments) — набор стандартов
описания интерфейсов взаимодействия операционной системы и прикладных
программ. Стандарты POSIX разработаны комитетом IEEE (Institute of
Electrical and Electronics Engineers) для обеспечения совместимости
различных UNIX/Linux-подобных опера- ционных систем и переносимости
прикладных программ на уровне исходного кода. POSIX-совместимые оболочки
разработаны на базе оболочки Корна.</p>
<h1 id="выполнение-лабораторной-работы">Выполнение лабораторной
работы</h1>
<h2
id="командный-файл-реализующий-упрощённый-механизм-семафоров">командный
файл, реализующий упрощённый механизм семафоров</h2>
<p>Чтобы создать данный командный файл, я создала новый файл и написала
в нем некоторый скрипт. Он устанавливает переменную lockfile для пути к
файлу блокировки, открывает файл для записи и назначает ему дескриптор
файла. Далее входит в цикл, который выполняется, пока файл блокировки
существует. Пытается получить эксклусивную блокировку для файла. Если
это удается, выводит “file locked”, ждет 5 секунд а затем выводит “file
unlocked”:</p>
<figure id="fig:001">
<img src="images/image1.png" style="width:70.0%"
alt="упрощённый механизм семафоров (код)" />
<figcaption aria-hidden="true">упрощённый механизм семафоров
(код)</figcaption>
</figure>
<pre><code>lockfile=&quot;./lock.file&quot;
exec {fn}&gt;$lockfile

while test -f &quot;$lockfile&quot;
do
if flock -n ${fn}
then
    echo &quot;File is locked&quot;
    sleep 5
    echo &quot;File is unlocked&quot;
    flock -u ${fn}
else
    echo &quot;File is locked&quot;
    sleep 5

fi
done    </code></pre>
<figure id="fig:002">
<img src="images/image2.png" style="width:70.0%"
alt="результаты кода" />
<figcaption aria-hidden="true">результаты кода</figcaption>
</figure>
<h2 id="реализовать-команду-man-с-помощью-командного-файла">Реализовать
команду man с помощью командного файла</h2>
<p>Я изучила содержимое каталога /usr/share/man/man1. В нем находятся
архивы текстовых файлов, содержащих справку по большинству установленных
в системе программ и команд:</p>
<figure id="fig:003">
<img src="images/image3.png" style="width:70.0%"
alt="ls /usr/share/man/man1" />
<figcaption aria-hidden="true">ls /usr/share/man/man1</figcaption>
</figure>
<p>Потом я создала файл и в нем написала скрипт реализирующий команды
man. Он принимает аргумент $1, проверяет существование файла в
/usr/share/man/man1, и если файл существует, использует less для
отображения содержимого сжатой страницы руководства. Если файл не
существует, выводит “invalid command”:</p>
<figure id="fig:004">
<img src="images/image4.png" style="width:70.0%"
alt="командный файл man" />
<figcaption aria-hidden="true">командный файл man</figcaption>
</figure>
<pre><code>a=$1
if test -f &quot;/usr/share/man/man1/$a.1.gz&quot;
then less /usr/share/man/man1/$a.1.gz
else
echo &quot;Invalid command&quot;
fi</code></pre>
<figure id="fig:005">
<img src="images/image5.png" style="width:70.0%"
alt="проверка командного файла man" />
<figcaption aria-hidden="true">проверка командного файла
man</figcaption>
</figure>
<figure id="fig:006">
<img src="images/image6.png" style="width:70.0%"
alt="проверка командного файла man" />
<figcaption aria-hidden="true">проверка командного файла
man</figcaption>
</figure>
<h2
id="написать-командный-файл-генерирующий-случайную-последовательность-букв-латинского-алфавита.">написать
командный файл, генерирующий случайную последовательность букв
латинского алфавита.</h2>
<p>Я написала скрипт который генерирует случайное число используя
$RANDOM, а затем с помощью tr заменяет каждую цифру на букву от ‘a-z’ и
‘A-Z’:</p>
<figure id="fig:007">
<img src="images/image7.png" style="width:70.0%"
alt="командный файл, генерирующий случайную последовательность букв" />
<figcaption aria-hidden="true">командный файл, генерирующий случайную
последовательность букв</figcaption>
</figure>
<pre><code>echo $RANDOM | tr &#39;0-9&#39; &#39;a-zA-Z&#39;</code></pre>
<figure id="fig:008">
<img src="images/image8.png" style="width:70.0%" alt="запуск скрипта" />
<figcaption aria-hidden="true">запуск скрипта</figcaption>
</figure>
<h1 id="выводы">Выводы</h1>
<p>При выполнении данной работы я научилась писать более сложные
командные файлы с использованием логических управляющих конструкций и
циклов.</p>
<h1 id="ответы-на-контрольные-вопросы">Ответы на контрольные
вопросы</h1>
<ol type="1">
<li><p>В данной строчке допущены следующие ошибки: не хватает пробелов
после первой скобки [ и перед второй скобкой ] выражение $1 необходимо
взять в “”, потому что эта переменная может содержать пробелы Таким
образом, правильный вариант должен выглядеть так: while [ “$1” != “exit”
]</p></li>
<li><p>Чтобы объединить несколько строк в одну, можно воспользоваться
несколькими способами: Первый: VAR1=“Hello,” VAR2=” World” VAR3=“<span
class="math inline"><em>V</em><em>A</em><em>R</em>1</span>VAR2” echo
“<span class="math inline">$VAR3" Результат: Hello, World Второй:
VAR1="Hello, " VAR1+=" World" echo "$</span>VAR1” Результат: Hello,
World</p></li>
<li><p>Команда seq в Linux используется для генерации чисел от ПЕРВОГО
до ПОСЛЕДНЕГО шага INCREMENT. Параметры: seq LAST: если задан только
один аргумент, он создает числа от 1 до LAST с шагом шага, равным 1.
Если LAST меньше 1, значение is не выдает. seq FIRST LAST: когда заданы
два аргумента, он генерирует числа от FIRST до LAST с шагом 1, равным 1.
Если LAST меньше FIRST, он не выдает никаких выходных данных. seq FIRST
INCREMENT LAST: когда заданы три аргумента, он генерирует числа от FIRST
до LAST на шаге INCREMENT. Если LAST меньше, чем FIRST, он не производит
вывод. seq -f «FORMAT» FIRST INCREMENT LAST: эта команда используется
для генерации последовательности в форматированном виде. FIRST и
INCREMENT являются необязательными. seq -s «STRING» ПЕРВЫЙ ВКЛЮЧЕНО: Эта
команда используется для STRING для разделения чисел. По умолчанию это
значение равно /n. FIRST и INCREMENT являются необязательными. seq -w
FIRST INCREMENT LAST: эта команда используется для выравнивания ширины
путем заполнения начальными нулями. FIRST и INCREMENT являются
необязательными.</p></li>
<li><p>Результатом данного выражения $((10/3)) будет 3, потому что это
целочисленное деление без остатка.</p></li>
<li><p>Отличия командной оболочки zsh от bash: В zsh более быстрое
автодополнение для cd с помощью Тab В zsh существует калькулятор zcalc,
способный выполнять вычисления внутри терминала В zsh поддерживаются
числа с плавающей запятой В zsh поддерживаются структуры данных «хэш» В
zsh поддерживается раскрытие полного пути на основенеполных данных В zsh
поддерживается замена части пути В zsh есть возможность отображать
разделенный экран, такой же как разделенный экран vim</p></li>
<li><p>for ((a=1; a &lt;= LIMIT; a++)) синтаксис данной конструкции
верен, потому что, используя двойные круглые скобки, можно не писать $
перед переменными ().</p></li>
<li><p>Преимущества и недостатки скриптового языка bash:</p></li>
</ol>
<p>Один из самых распространенных и ставится по умолчанию в большинстве
дистрибутивах Linux, MacOS Удобное перенаправление ввода/вывода Большое
количество команд для работы с файловыми системами Linux Можно писать
собственные скрипты, упрощающие работу в Linux Недостатки скриптового
языка bash: Дополнительные библиотеки других языков позволяют выполнить
больше действий Bash не является языков общего назначения Утилиты, при
выполнении скрипта, запускают свои процессы, которые, в свою очередь,
отражаются на быстроте выполнения этого скрипта Скрипты, написанные на
bash, нельзя запустить на других операционных системах без
дополнительных действий</p>
<h1 class="unnumbered" id="список-литературы">Список литературы</h1>
<p><a
href="https://esystem.rudn.ru/pluginfile.php/2288101/mod_resource/content/4/012-lab_shell_prog_3.pdf">Архитектура
ЭВМ</a></p>
